#!/usr/bin/env python
# -*- Mode: python -*-
#
# Usage: pslurp [OPTIONS] -h hosts.txt -o outdir remote local
#
# Parallel scp from the set of nodes in hosts.txt.  For each node, we
# essentially do a scp [-r] user@host:remote outdir/<node>/local.  This
# program also uses the -q (quiet) and -C (compression) options.  Note
# that remote must be an absolute path.
#
# Created: 18 November 2003
#
# $Id: pslurp 400 2008-10-12 11:48:28Z bnc $
#
import fcntl
import os
import re
import signal
import subprocess
import sys
import threading
    
basedir, bin = os.path.split(os.path.dirname(os.path.abspath(sys.argv[0])))
sys.path.append("%s" % basedir)
    
from psshlib import psshutil
from psshlib.basethread import BaseThread
from psshlib.cli import common_parser, common_defaults

def option_parser():
    parser = common_parser()
    parser.usage = "%prog [OPTIONS] -h hosts.txt remote local"
    parser.epilog = ("Example: pslurp -h hosts.txt -L /tmp/outdir -l irb2 " +
            "         /home/irb2/foo.txt foo.txt")

    parser.add_option('-r', '--recursive', dest='recursive',
            action='store_true', help='recusively copy directories (OPTIONAL)')
    parser.add_option('-L', '--localdir', dest='localdir',
            help='output directory for remote file copies')

    return parser

def parse_args():
    parser = option_parser()
    defaults = common_defaults()
    parser.set_defaults(**defaults)
    opts, args = parser.parse_args()

    if len(args) < 1:
        parser.error('Paths not specified.')

    if len(args) < 2:
        parser.error('Local path not specified.')

    if len(args) > 2:
        parser.error('Extra arguments given after the local path.')

    if not opts.hosts:
        parser.error('Hosts not specified.')

    return opts, args

def do_pslurp(hosts, ports, users, remote, local, opts):
    if opts.localdir and not os.path.exists(opts.localdir):
        os.makedirs(opts.localdir)
    if opts.outdir and not os.path.exists(opts.outdir):
        os.makedirs(opts.outdir)
    if opts.errdir and not os.path.exists(opts.errdir):
        os.makedirs(opts.errdir)
    for host in hosts:
        if opts.localdir:
            dirname = "%s/%s" % (opts.localdir, host)
        else:
            dirname = host
        if not os.path.exists(dirname):
            os.mkdir(dirname)
    sem = threading.Semaphore(opts.par)
    threads = []
    for i in range(len(hosts)):
        sem.acquire()
        if opts.localdir:
            localpath = "%s/%s/%s" % (opts.localdir, hosts[i], local)
        else:
            localpath = "%s/%s" % (hosts[i], local)
        if opts.options and opts.recursive:
            cmd = "scp -o \"%s\" -qrC -P %d %s@%s:%s %s" % \
                  (opts.options, ports[i], users[i], hosts[i],
                   remote, localpath)
        elif opts.options and not opts.recursive:
            cmd = "scp -o \"%s\" -qC -P %d %s@%s:%s %s" % \
                  (opts.options, ports[i], users[i], hosts[i],
                   remote, localpath)
        elif not opts.options and opts.recursive:
            cmd = "scp -qrC -P %d %s@%s:%s %s" % \
                  (ports[i], users[i], hosts[i], remote, localpath)
        else:
            cmd = "scp -qC -P %d %s@%s:%s %s" % \
                  (ports[i], users[i], hosts[i], remote, localpath)
        t = BaseThread(hosts[i], ports[i], cmd, opts, sem)
        t.start()
        threads.append(t)
    for t in threads:
        t.join()

if __name__ == "__main__":
    subprocess._cleanup = lambda : None
    opts, args = parse_args()
    remote = args[0]
    local = args[1]
    if not re.match("^/", remote):
        print "Remote path %s must be an absolute path" % remote
        sys.exit(3)
    hosts, ports, users = psshutil.read_hosts(opts.hosts)
    psshutil.patch_users(hosts, ports, users, opts.user)
    signal.signal(signal.SIGCHLD, signal.SIG_DFL)
    os.setpgid(0, 0)
    do_pslurp(hosts, ports, users, remote, local, opts)
