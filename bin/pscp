#!/usr/bin/env python2.2
# -*- Mode: python -*-
#
# Usage: pscp [OPTIONS] -h hosts.txt local remote
#
# Parallel scp to the set of nodes in hosts.txt.  For each node,
# we essentially do a scp [-r] local user@host:remote.  This program
# also uses the -q (quiet) and -C (compression) options.  Note
# that remote must be an absolute path.
#
# Created: 16 August 2003
#
# $Id: pscp,v 1.6 2003/11/13 09:10:17 bnc Exp $
#
import fcntl, os, popen2, select, signal, sys, threading, time
sys.path.append("/usr/local/lib/python2.2")

_DEFAULT_PARALLELISM = 32
_DEFAULT_TIMEOUT     = None  # No timeout by default

class scp_thread(threading.Thread):
    def __init__(self, host, port, user, local, remote, flags, sem):
        threading.Thread.__init__(self)
        self.host = host
        self.port = port
        if flags["options"] and flags["recursive"]:
            self.cmd = "scp -o \"%s\" -qrC -P %d %s %s@%s:%s" % \
                       (flags["options"], port, local, user, host, remote)
        elif flags["options"] and not flags["recursive"]:
            self.cmd = "scp -o \"%s\" -qC -P %d %s %s@%s:%s" % \
                       (flags["options"], port, local, user, host, remote)
        elif not flags["options"] and flags["recursive"]:
            self.cmd = "scp -qrC -P %d %s %s@%s:%s" % \
                       (port, local, user, host, remote)
        else:
            self.cmd = "scp -qC -P %d %s %s@%s:%s" % \
                       (port, local, user, host, remote)
        self.sem = sem

    def run(self):
        try:
            child = popen2.Popen3(self.cmd)
            cstdout = child.fromchild
            fcntl.fcntl(cstdout.fileno(), fcntl.F_SETFL, os.O_NONBLOCK)
            start = time.time()
            while 1:
                if flags["timeout"]:
                    timeout = flags["timeout"] - (time.time() - start)
                    if timeout <= 0:
                        raise "Timeout on %s:%d" % (self.host, self.port)
                else:
                    timeout = flags["timeout"]
                r, w, e = select.select([cstdout, ], [], [], timeout)
                try:
                    chunk = cstdout.read()
                    if len(chunk) == 0:
                        break
                except:
                    os.kill(child.pid, signal.SIGKILL)                
                    raise
            print "Success on %s:%d" % (self.host, self.port)
            sys.stdout.flush()
        except:
            print "Error on %s:%d" % (self.host, self.port)
        self.sem.release()
        
def print_usage():
    print "Usage: pscp [OPTIONS] -h hosts.txt local remote"
    print
    print "  -h --hosts     hosts file (each line \"host[:port] [login]\")"
    print "  -r --recursive recusively copy directories (OPTIONAL)"  
    print "  -l --user      username (OPTIONAL)"
    print "  -p --par       max number of parallel threads (OPTIONAL)"
    print "  -t --timeout   timeout in seconds to do scp to a host (OPTIONAL)"    
    print "  -O --options   SSH options (OPTIONAL)"    
    print
    print "Example: pscp -h hosts.txt -l irb2 foo.txt /home/irb2/foo.txt" 
    print 

def read_envvars(flags):
    if os.getenv("PSSH_HOSTS"):
        flags["hosts"] = os.getenv("PSSH_HOSTS")
    if os.getenv("PSSH_USER"):
        flags["user"] = os.getenv("PSSH_USER")
    if os.getenv("PSSH_PAR"):
        flags["par"] = int(os.getenv("PSSH_PAR"))
    if os.getenv("PSSH_TIMEOUT"):
        flags["timeout"] = int(os.getenv("PSSH_TIMEOUT"))
    if os.getenv("PSSH_OPTIONS"):
        flags["options"] = os.getenv("PSSH_OPTIONS")

def parsecmdline(argv):
    import getopt
    shortopts = "h:rl:p:t:O:"
    longopts = [ "hosts" , "recursive", "user", "par", "timeout", "options" ]
    flags = { "hosts" : None, "recursive" : None, "user" : None,
              "par" : _DEFAULT_PARALLELISM, "timeout" : _DEFAULT_TIMEOUT,
              "options" : None }
    read_envvars(flags)
    opts, args = getopt.getopt(argv[1:], shortopts, longopts)
    for o, v in opts:
        if o in ("-h", "--hosts"):
            flags["hosts"] = v
        elif o in ("-r", "--recursive"):
            flags["recursive"] = 1
        elif o in ("-l", "--user"):
            flags["user"] = v
        elif o in ("-p", "--par"):
            flags["par"] = int(v)
        elif o in ("-t", "--timeout"):
            flags["timeout"] = int(v)
        elif o in ("-O", "--options"):
            flags["options"] = v
    # Required flags
    if not flags["hosts"]:
        print_usage()
        sys.exit(3)
    return args, flags

def do_pscp(hosts, ports, users, local, remote, flags):
    import os
    sem = threading.Semaphore(flags["par"])
    for i in range(len(hosts)):
        sem.acquire()
        t = scp_thread(hosts[i], ports[i], users[i], local, remote, 
                       flags, sem)
        t.start()

if __name__ == "__main__":
    import os, pwd, re, psshutil
    args, flags = parsecmdline(sys.argv)
    if len(args) != 2:
        print_usage()
        sys.exit(3)
    local = args[0]
    remote = args[1]
    if not re.match("^/", remote):
        print "Remote path %s must be an absolute path" % remote
        sys.exit(3)
    hosts, ports, users = psshutil.read_hosts(flags["hosts"])
    psshutil.patch_users(hosts, ports, users, flags["user"])
    do_pscp(hosts, ports, users, local, remote, flags)
