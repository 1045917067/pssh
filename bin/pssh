#!/usr/bin/env python
# -*- Mode: python -*-
#
# Usage: pssh [OPTIONS] -h hosts.txt prog [arg0] [arg1] ..
#
# Parallel ssh to the set of nodes in hosts.txt. For each node, this
# essentially does an "ssh host -l user prog [arg0] [arg1] ...". The -o
# option can be used to store stdout from each remote node in a
# directory.  Each output file in that directory will be named by the
# corresponding remote node's hostname or IP address.
#
# Created: 16 August 2003
#
# $Id: pssh 400 2008-10-12 11:48:28Z bnc $
#
import fcntl
import getopt
import optparse
import os
import pwd
import signal
import subprocess
import sys
import threading

basedir, bin = os.path.split(os.path.dirname(os.path.abspath(sys.argv[0])))
sys.path.append("%s" % basedir)

from psshlib import psshutil
from psshlib.basethread import BaseThread

_DEFAULT_PARALLELISM = 32
_DEFAULT_TIMEOUT     = 60

def option_parser():
    # The "resolve" conflict handler avoids errors from the hosts option
    # conflicting with the help option.
    parser = optparse.OptionParser(conflict_handler='resolve')
    # Ensure that options appearing after the command are sent to ssh.
    parser.disable_interspersed_args()
    parser.usage = "pssh [OPTIONS] -h hosts.txt command [ARGS]"
    parser.epilog = "Example: pssh -h nodes.txt -l irb2 -o /tmp/foo uptime"

    parser.add_option('-h', '--hosts', dest='hosts',
            help='hosts file (each line "host[:port] [user]")')
    parser.add_option('-l', '--user', dest='user',
            help='username (OPTIONAL)')
    parser.add_option('-p', '--par', dest='par', type='int',
            help='max number of parallel threads (OPTIONAL)')
    parser.add_option('-o', '--outdir', dest='outdir',
            help='output directory for stdout files (OPTIONAL)')
    parser.add_option('-e', '--errdir', dest='errdir',
            help='output directory for stderr files (OPTIONAL)')
    parser.add_option('-t', '--timeout', dest='timeout', type='int',
            help='timeout (secs) (-1 = no timeout) per host (OPTIONAL)')
    parser.add_option('-O', '--options', dest='options',
            help='SSH options (OPTIONAL)')
    parser.add_option('-v', '--verbose', dest='verbose', action='store_true',
            help='turn on warning and diagnostic messages (OPTIONAL)')
    parser.add_option('-P', '--print', dest='print_out', action='store_true',
            help='print output as we get it (OPTIONAL)')
    parser.add_option('-i', '--inline', dest='inline', action='store_true',
            help='inline aggregated output for each server (OPTIONAL)')

    current_user = pwd.getpwuid(os.getuid())[0]
    defaults = dict(par=_DEFAULT_PARALLELISM, timeout=_DEFAULT_TIMEOUT,
            user=current_user)
    envvars = [('hosts', 'PSSH_HOSTS'),
            ('user', 'PSSH_USER'),
            ('par', 'PSSH_PAR'),
            ('outdir', 'PSSH_OUTDIR'),
            ('errdir', 'PSSH_ERRDIR'),
            ('timeout', 'PSSH_TIMEOUT'),
            ('options', 'PSSH_OPTIONS'),
            ('verbose', 'PSSH_VERBOSE'),
            ('print_out', 'PSSH_PRINT'),
            ('inline', 'PSSH_INLINE'),
            ]
    for option, var, in envvars:
        value = os.getenv(var)
        if value:
            defaults[option] = value

    parser.set_defaults(**defaults)
    return parser

def parse_args():
    parser = option_parser()
    opts, args = parser.parse_args()
    #switch to this?: if opts.timeout <= 0:
    if opts.timeout == -1:
        opts.timeout = None

    if len(args) == 0:
        parser.error('Command not specified.')

    if not opts.hosts:
        parser.error('Hosts not specified.')

    return opts, args

def buffer_input():
    origfl = fcntl.fcntl(sys.stdin.fileno(), fcntl.F_GETFL)
    fcntl.fcntl(sys.stdin.fileno(), fcntl.F_SETFL, origfl | os.O_NONBLOCK)
    try:
        stdin = sys.stdin.read()
    except IOError: # Stdin contained no information
        stdin = ""
    fcntl.fcntl(sys.stdin.fileno(), fcntl.F_SETFL, origfl)
    return stdin

def do_pssh(hosts, ports, users, cmdline, opts):
    if opts.outdir and not os.path.exists(opts.outdir):
        os.makedirs(opts.outdir)
    if opts.errdir and not os.path.exists(opts.errdir):
        os.makedirs(opts.errdir)
    stdin = buffer_input()
    sem = threading.Semaphore(opts.par)
    threads = []
    for i in range(len(hosts)):
        sem.acquire()
        if opts.verbose:
            quietswitch = ""
        else:
            quietswitch = "-q"
        if opts.options:
            cmd = "ssh -o \"%s\" %s -p %s -l %s %s \"%s\"" % \
                       (opts.options, hosts[i], ports[i], users[i],
                        quietswitch, cmdline)
        else:
            cmd = "ssh %s -p %s -l %s %s \"%s\"" % \
                       (hosts[i], ports[i], users[i], quietswitch, cmdline)
        t = BaseThread(hosts[i], ports[i], cmd, opts, sem, stdin)
        t.start()
        threads.append(t)
    for t in threads:
        t.join()
   
if __name__ == "__main__":
    subprocess._cleanup = lambda : None
    opts, args = parse_args()
    cmdline = " ".join(args)
    hosts, ports, users = psshutil.read_hosts(opts.hosts)
    psshutil.patch_users(hosts, ports, users, opts.user)
    signal.signal(signal.SIGCHLD, signal.SIG_DFL)
    os.setpgid(0, 0)
    do_pssh(hosts, ports, users, cmdline, opts)
